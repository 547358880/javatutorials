## 类加载

### **加载(Loading)**
在加载阶段，虚拟机需要完成以下3件事情
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流锁代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

### **验证**

### **准备**

### **解析**

### **初始化**

## 类加载器
从java虚拟机角度来讲,只存在两种不同的类加载器:一种是启动类加载器(Bootstrap ClassLoader),这个类加载器使用C++实现，是虚拟机自身的一部分;另外一种就是所有其他的类加载器，这些类加载器都是由Java实现，独立虚拟机外部，并都继承抽象类java.lang.ClassLoader  
从开发人员角度来看绝大部分程序都会用到以下3中系统提供的类加载器:
- **启动类加载器(Bootstrap ClassLoader)**: 这个类加载器将存放在<JAVA_HOME>\lib目录中，或者被-Xbootclasspath参数所指定的路径中，并且是虚拟机识别的(如rt.jar)类库加载到虚拟机中,启动类加载器无法被Java程序直接引用，在编写自定义加载器时，如果需要把加载委托给引导类加载器，那么直接使用null代替
- **扩展类加载器(Extension ClassLoader)**: 这个加载器由sun.misc.Launcher$ExClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定路径中的所有类库
- **应用程序类加载器(Application ClassLoader)**: 这个类加载器由sun.misc.Launcher$AppClassLoader实现，这个类加载器是ClassLoader中getSystemClassLoader()方法的返回值，所以称为类加载器，它负责加载用户类路径(ClassPath)上所指定的类库

### 双亲委派模型
**工作流程是:如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只用当父类加载器反馈自己无法完成这个加载请求(在搜索范围内没有找到所需的类)时,子类加载器才会尝试自己去加载**

参考资料:
深入理解Java虚拟机